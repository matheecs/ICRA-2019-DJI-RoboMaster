/*********************************************************************
*
* Software License Agreement (BSD License)
*
*  Copyright (c) 2009, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Willow Garage, Inc. nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*
* Author: Eitan Marder-Eppstein
*********************************************************************/
#ifndef ROBORTS_PLANNING_DWA_ALG_H_
#define ROBORTS_PLANNING_DWA_ALG_H_

#include <angles/angles.h>

#include "local_planner/data_base.h"
#include "local_planner/map_grid.h"
#include "local_planner/robot_position_cost.h"

namespace roborts_local_planner {
/**
 * @class DWAAlg
 * @brief implementing a local planner using the Dynamic Window Approach Algorithm
 */

class DWAAlg{
public:
  DWAAlg(std::vector<Eigen::Vector2d>& footprint_spec,
         std::shared_ptr<roborts_local_planner::RobotPositionCost> robot_cost,
         roborts_costmap::Costmap2D* costmap, double robot_inscribed_radius, 
         double robot_circumscribed_radius, double max_vel_x = 2.0,
         double max_vel_y = 2.0, double max_vel_theta = 2.0,
         double min_vel_x = 0.05, double min_vel_y = 0.05,
         double min_vel_theta = -2.0, double acc_lim_x = 2.0,
         double acc_lim_y = 2.0, double acc_lim_theta = 2.0,
         double min_in_place_vel_th = 0.4, double backup_vel = -2.0,
         double heading_lookahead  = 0.325, bool dwa = false, bool heading_scoring = false,
         bool simple_attractor = false, bool holonomic_robot = true,
         double vx_samples = 20, double vy_samples = 20, double vtheta_samples = 20,
         double sim_time = 1.0, double sim_granularity = 0.025, double angular_sim_granularity = 0.025,
         double heading_scoring_timestep = 0.1, double pdist_scale = 0.6, double gdist_scale = 0.8, 
         double occdist_scale = 0.2, double sim_period = 0.1,
         double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2,
         double oscillation_reset_dist = 0.05);

  ~DWAAlg() {}
   
  /**
   * @brief Entry function of dwa algorithm
   * @param global_pose Start pose of robot
   * @param global_vel Start velocity of robot
   * @param local_path Output path is generated by dwa
   * @param drive_velocities Velocities will be sent to robot base
   */
  bool findBestPath(const DataBase& global_pose, 
                     const geometry_msgs::Twist& global_vel,
                     TrajectoryDataBase& local_path,
                     geometry_msgs::Twist& drive_velocities);
  /**
   * @brief  Update the global_plan
   * @param new_plan A new global plan
   * @param compute_dists Whether or not to compute path/goal distances when a plan is updated
   */
  void updatePlan(const TrajectoryDataBase& new_plan, bool compute_dists = true);

  /**
   * @brief  Create the trajectories we wish to explore, score them, and return the best option
   * @param x The x position of the robot  
   * @param y The y position of the robot  
   * @param theta The orientation of the robot
   * @param vx The x velocity of the robot
   * @param vy The y velocity of the robot
   * @param vtheta The theta velocity of the robot
   * @param acc_x The x acceleration limit of the robot
   * @param acc_y The y acceleration limit of the robot
   * @param acc_theta The theta acceleration limit of the robot
   * @param best_path Output
   */
  bool createTrajectories(double x, double y, double theta, 
                            double vx, double vy, double vtheta, 
                            double acc_x, double acc_y, double acc_theta,
                            TrajectoryDataBase& best_path);

  /**
   * @brief  Generate and score a single trajectory
   * @param x The x position of the robot  
   * @param y The y position of the robot  
   * @param theta The orientation of the robot
   * @param vx The x velocity of the robot
   * @param vy The y velocity of the robot
   * @param vtheta The theta velocity of the robot
   * @param vx_samp The x velocity used to seed the trajectory
   * @param vy_samp The y velocity used to seed the trajectory
   * @param vtheta_samp The theta velocity used to seed the trajectory
   * @param acc_x The x acceleration limit of the robot
   * @param acc_y The y acceleration limit of the robot
   * @param acc_theta The theta acceleration limit of the robot
   * @param impossible_cost The cost value of a cell in the local map grid that is considered impassable
   * @param traj Will be set to the generated trajectory with its associated score 
   */
  bool generateTrajectory(double x, double y, double theta, double vx, double vy, 
          double vtheta, double vx_samp, double vy_samp, double vtheta_samp, double acc_x, double acc_y,
          double acc_theta, double impossible_cost, TrajectoryDataBase& traj);
  /**
   * @brief  Generate and score a single trajectory
   * @param x The x position of the robot  
   * @param y The y position of the robot  
   * @param theta The orientation of the robot
   * @param vx The x velocity of the robot
   * @param vy The y velocity of the robot
   * @param vtheta The theta velocity of the robot
   * @param vx_samp The x velocity used to seed the trajectory
   * @param vy_samp The y velocity used to seed the trajectory
   * @param vtheta_samp The theta velocity used to seed the trajectory
   * @return True if the trajectory is legal, false otherwise
   */
  bool checkTrajectory(double x, double y, double theta, double vx, double vy, 
           double vtheta, double vx_samp, double vy_samp, double vtheta_samp);

  /**
   * @brief  Generate and score a single trajectory
   * @param x The x position of the robot  
   * @param y The y position of the robot  
   * @param theta The orientation of the robot
   * @param vx The x velocity of the robot
   * @param vy The y velocity of the robot
   * @param vtheta The theta velocity of the robot
   * @param vx_samp The x velocity used to seed the trajectory
   * @param vy_samp The y velocity used to seed the trajectory
   * @param vtheta_samp The theta velocity used to seed the trajectory
   * @return The score (as double)
   */
  double scoreTrajectory(double x, double y, double theta, double vx, double vy, 
              double vtheta, double vx_samp, double vy_samp, double vtheta_samp);

private:
  double headingDiff(int cell_x, int cell_y, double x, double y, double heading);
  std::shared_ptr<roborts_local_planner::RobotPositionCost> robot_cost_; ///< @brief Robot footprint cost
  roborts_costmap::Costmap2D* costmap_; ///< @brief Provides access to cost map information
  TrajectoryDataBase global_plan_; //path which is generated by global path planner
  MapGrid path_map_; ///< @brief The local map grid where we propagate path distance
  MapGrid goal_map_; ///< @brief The local map grid where we propagate goal distance

  TrajectoryDataBase traj_one_, traj_two_; ///< @brief Used for scoring trajectories
  
  std::vector<Eigen::Vector2d> footprint_spec_;///< @brief Robot footprint
  double max_vel_x_, max_vel_y_, max_vel_theta_;
  double min_vel_x_, min_vel_y_, min_vel_theta_;
  double acc_lim_x_, acc_lim_y_, acc_lim_theta_; 
  double min_in_place_vel_th_;
  double backup_vel_; ///< @brief The velocity to use while backing up
  double heading_lookahead_; ///< @brief How far the robot should look ahead of itself when differentiating between different rotational velocities
  double robot_inscribed_radius_;
  double robot_circumscribed_radius_; 

  bool dwa_;  ///< @brief Should we use the dynamic window approach?
  bool heading_scoring_; ///< @brief Should we score based on the rollout approach or the heading approach
  bool simple_attractor_;  ///< @brief Enables simple attraction to a goal point
  bool escaping_; ///< @brief Boolean to keep track of whether we're in escape mode
  bool holonomic_robot_; ///< @brief Is the robot holonomic or not? 

  bool stuck_left_, stuck_right_; ///< @brief Booleans to keep the robot from oscillating during rotation
  bool rotating_left_, rotating_right_; ///< @brief Booleans to keep track of the direction of rotation for the robot
  bool stuck_left_strafe_, stuck_right_strafe_; ///< @brief Booleans to keep the robot from oscillating during strafing
  bool strafe_right_, strafe_left_; ///< @brief Booleans to keep track of strafe direction for the robot
  int vx_samples_, vy_samples_, vtheta_samples_; ///< @brief The number of samples we'll take in the x, y, theta dimension of the control space
  double sim_time_; ///< @brief The number of seconds each trajectory is "rolled-out"
  double sim_granularity_; ///< @brief The distance between simulation points
  double angular_sim_granularity_; ///< @brief The distance between angular simulation points
  double heading_scoring_timestep_; ///< @brief How far to look ahead in time when we score a heading
  double pdist_scale_, gdist_scale_, occdist_scale_; ///< @brief Scaling factors for the controller's cost function
  double sim_period_; ///< @brief The number of seconds to use to compute max/min vels for dwa
  double prev_x_, prev_y_; ///< @brief Used to calculate the distance the robot has traveled before reseting oscillation booleans
  double escape_x_, escape_y_, escape_theta_; ///< @brief Used to calculate the distance the robot has traveled before reseting escape booleans
  double escape_reset_dist_, escape_reset_theta_; ///< @brief The distance the robot must travel before it can leave escape mode
  double oscillation_reset_dist_; ///< @brief The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past
  
  boost::mutex configuration_mutex_;

  /**
   * @brief  Compute x position based on velocity
   * @param  xi The current x position
   * @param  vx The current x velocity
   * @param  vy The current y velocity
   * @param  theta The current orientation
   * @param  dt The timestep to take
   * @return The new x position 
   */
  inline double computeNewXPosition(double xi, double vx, double vy, double theta, double dt){
    return xi + (vx * cos(theta) + vy * cos(M_PI_2 + theta)) * dt;
  }

  /**
   * @brief  Compute y position based on velocity
   * @param  yi The current y position
   * @param  vx The current x velocity
   * @param  vy The current y velocity
   * @param  theta The current orientation
   * @param  dt The timestep to take
   * @return The new y position 
   */
  inline double computeNewYPosition(double yi, double vx, double vy, double theta, double dt){
    return yi + (vx * sin(theta) + vy * sin(M_PI_2 + theta)) * dt;
  }
  /**
   * @brief  Compute orientation based on velocity
   * @param  thetai The current orientation
   * @param  vth The current theta velocity
   * @param  dt The timestep to take
   * @return The new orientation
   */
  inline double computeNewThetaPosition(double thetai, double vth, double dt){
    return thetai + vth * dt;
  }

  /**
   * @brief  Compute velocity based on acceleration
   * @param vg The desired velocity, what we're accelerating up to 
   * @param vi The current velocity
   * @param a_max An acceleration limit
   * @param  dt The timestep to take
   * @return The new velocity
   */
  inline double computeNewVelocity(double vg, double vi, double a_max, double dt){
    if((vg - vi) >= 0) {
      return std::min(vg, vi + a_max * dt);
    }
    return std::max(vg, vi - a_max * dt);
  }
}; // class DWAAlg
} //namespace roborts_local_planner

#endif //ROBORTS_PLANNING_DWA_ALG_H_
